1. what are the features of spring boot 3 release?
answer:
Spring Boot 3 is a major release of the Spring Boot framework, released in November 2022. It includes several new features, improvements and bug fixes:

a. Java 17 baseline: Spring Boot 3 requires Java 17 or higher. This means you can take advantage of the latest features and performance improvements that Java 17 offers.
b. Support for generating native images with GraalVM: GraalVM is a high-performance virtual machine that can be used to generate native images of your Spring Boot applications. This can
significantly improve the performance of your applications, especially on startup.
c. Improved observability with Micrometer and Micrometer Tracing: Micrometer is a library that provides a unified API for collecting metrics from your Spring Boot applications. Micrometer Tracing is a library that provides tracing support for your Spring Boot applications. These libraries make it easier to monitor and troubleshoot your applications.
d. Support for Jakarta EE 10 with an EE 9 baseline: Jakarta EE 10 is the latest version of the Jakarta EE specification. Spring Boot 3 includes support for Jakarta EE 10, so you can now use Spring Boot to develop applications that are compliant with the Jakarta EE 10 specification.
e. Spring Framework 6: Spring Boot 3 is based on Spring Framework 6, so it includes all of the new features and improvements that were introduced in Spring Framework 6.


--------------------------

2. what are spring boot profiles?
Answer:
Spring Profiles provide a way to segregate parts of your application configuration and make it be available only in certain environments. Any @Component, @Configuration or @ConfigurationProperties can be marked with @Profile to limit when it is loaded, as shown in the following example:
Sample Code:
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

@Configuration(proxyBeanMethods = false)
@Profile("production")
public class ProductionConfiguration {
	// ...
}

You can use a spring.profiles.active Environment property to specify which profiles are active. You can specify the property. For example, you could include it in your application.properties, as shown in the following example:
Properties:
spring.profiles.active=dev

Summary
Spring Boot Profiles are a powerful tool for managing environment-specific configurations.
They promote flexibility and maintainability by allowing an application to adapt to different environments seamlessly.
By following a few simple steps, developers can create and activate profiles to control an applicationâ€™s behavior in various contexts.

--------------

3. what is dependency injection in spring or spring boot? what are the advantages of dependency injection?
answer:

Dependency Injection (DI) is a design pattern in software engineering where the dependencies of a class or component are provided externally, usually by a framework or container, rather than the class creating or managing its own dependencies internally. This pattern promotes loose coupling, modularity, and testability by separating the creation and configuration of objects from their usage, allowing for easier changes, better maintainability, and improved software design.

Where 

In the context of Spring or Spring Boot:

Dependency refers to an object or service that another class relies on to perform its functions or tasks. For example, a service class may depend on a repository interface to interact with the database.

Injection is the process of providing these dependencies to a class from an external source (i.e., a DI container or framework) rather than the class creating or managing them internally. The framework is responsible for injecting the required dependencies into the classes. 

Key points or advantages about Dependency Injection in Spring or Spring Boot:

Decoupling: DI promotes loose coupling between classes or components by separating the creation and configuration of objects from their usage.

Flexibility: It allows for easier changes in dependencies or configurations without modifying the code, which improves the flexibility and maintainability of the application.

Testing: DI facilitates easier testing by enabling the use of mock or stub objects for testing components independently.

Code Reusability: With DI, components are more reusable as they are not tightly bound to specific implementations of their dependencies. This allows for swapping out implementations easily, promoting code reuse across different parts of the application.

separating the concerns of object creation and dependency management from the business logic of the application. This separation leads to a more modular and understandable codebase, making it easier to maintain and scale the application.

Reduced Boilerplate Code: By handling the creation and injection of dependencies, DI reduces the amount of boilerplate code required in the application, leading to cleaner and more concise code.

----------
4. difference between arraylist and copyonaraylist?
answer:
https://www.tutorialspoint.com/Difference-between-ArrayList-and-CopyOnWriteArrayList-in-Java

---------

5. difference between hashmap and concurrent hashmap?
answer:
https://www.javatpoint.com/hashmap-vs-concurrenthashmap-in-java


--------
6. different ways to inject external properties into spring boot application?
ans:
In Spring Boot, there are several ways to inject external properties into your application.

1. Using @Value Annotation:
The @Value annotation is used to inject individual properties from application.properties or application.yml directly into Spring beans.
@Value("${myapp.name}")
    private String appName;

2. Using @ConfigurationProperties:
The @ConfigurationProperties annotation is used to bind a group of properties to a Java bean.
You can inject and use this bean throughout your application code just like any other spring bean.
application.properties file
myapp.name=My Spring Boot App
myapp.port=8080
myapp.enabled=true


import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "myapp")
public class MyAppProperties {

    private String name;
    private int port;
    private boolean enabled;

    // getters and setters
}

b. We can also use @ConfigurationProperties annotation on @Bean-annotated methods.
lets say application.properties
#Book
book.bookTitle= New Book
book.price= 150
book.isbn = 3523634523f342
example of class:

book.class
public class Book {
 
    private String bookTitle;
 
    private Double price;
 
    private String isbn;
 
    //getters and setters
}

mapping the configuration:

@Configuration
public class BeanConfigProperties {
 
    @Bean
    @ConfigurationProperties(prefix = "book")
    public Book book()
    {
        return  new Book();
    }
}
3.Using Environment:
The Environment interface is used to programmatically access properties
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    @Autowired
    private Environment env;

    public void printProperties() {
        String appName = env.getProperty("myapp.name");
        int port = Integer.parseInt(env.getProperty("myapp.port"));
        boolean enabled = Boolean.parseBoolean(env.getProperty("myapp.enabled"));

        System.out.println("Name: " + appName);
        System.out.println("Port: " + port);
        System.out.println("Enabled: " + enabled);
    }
}


4. Using Command Line Arguments:
Command line arguments can override properties defined in application.properties or application.yml.
java -jar myapp.jar --myapp.name=MyNewAppName


5. Using @PropertySource Annotation:
@PropertySource annotation in Spring is used to declare a set of properties files to be loaded into the Spring Environment. This allows you to externalize your configuration and keep your application configuration clean and organized.To be used in conjunction with @Configuration classes.
which we can use in conjunction with @value, environment variables, @configurationProperties

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@PropertySource("classpath:myapp.properties")
public class AppConfig {
    // This class can be used to load external properties
}

------------------
